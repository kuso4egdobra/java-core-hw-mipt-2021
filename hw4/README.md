# Задание №1 | Принцип работы программы 

Создаются 4 потокабезопасные очереди: одна для ожидания прохода кораблей через туннель,
другие для ожидания погрузки. 

### Генератор
Создается **генератор**, у которого есть метод `run`,
обеспечивающий генерацию n-ое кол-во кораблей. Каждый корабль при генерации 
заносится в очередь ожидания прохода через туннель.

### Туннель
Создается **туннель**, который содержит в себе 3 потока, каждый из который 
пытается достать карабль из очереди ожидания. При удачной попытке, поток засыпает
на 1 секунду, затем в зависимости от типа перевозимого груза добавляет корабль 
в очередь погрузки на нужный причал.

### Причал
Создаются 3 причала, каждый пытается достать из своей очереди погрузки
корабль. Если корабль удалось достать, поток засыпает на необходимое кол-во
секунд, после чего инкрементируется static atomic счетчик обработанных кораблей.


### Завершение работы программы
Main поток ожидает погрузку всех кораблей с помощью `condition-await`.
При каждом погруженном корабле причал сигнализирует `signalAll` о необходимости
проверки кол-ва погруженных кораблей. Программа завершается обходом всех поток и вызовом 
метода `shutdownNow()`

# Задание №2 | Принцип работы программы

### RingProcessor
Процессор отвечает за создание и запуск системы. Так же он ожидает с помощью
`condition-await` пока все заявки не будут обработаны. В случае всех обработанных заявок
процессор вызывает метод `shutdownNow()` у всех узлов.

### Node
У каждого узла создается своя потокобезопасная очередь и 3 потока. При запуске метода
`run` каждый поток обращается к очереди и пытается получить заявку. При получении
заявки поток проверяет является ли он `destination`.
Если нет, то поток засыпает и затем отправляет заявку следующему узлу.
Если да, то он отправляет заявку
`coreNode`, где происходит его добавление в очередь для обработанных заявок,
а также сигнализирование RingProcessor'у о том, что необходимо проверить кол-во
обработанных заявок.

### DataPackage
Каждая заявка содержит в себе потокобезопасную очередь для записи времени, проведенного
в каждом узле. В дальнейшем эта очередь используется для подсчета среднего времени,
проведенного в узле.